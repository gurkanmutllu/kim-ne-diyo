'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

require("regenerator-runtime/runtime.js");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/web.url.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.typed-array.uint8-array.js");

require("core-js/modules/es.typed-array.copy-within.js");

require("core-js/modules/es.typed-array.every.js");

require("core-js/modules/es.typed-array.fill.js");

require("core-js/modules/es.typed-array.filter.js");

require("core-js/modules/es.typed-array.find.js");

require("core-js/modules/es.typed-array.find-index.js");

require("core-js/modules/es.typed-array.for-each.js");

require("core-js/modules/es.typed-array.includes.js");

require("core-js/modules/es.typed-array.index-of.js");

require("core-js/modules/es.typed-array.iterator.js");

require("core-js/modules/es.typed-array.join.js");

require("core-js/modules/es.typed-array.last-index-of.js");

require("core-js/modules/es.typed-array.map.js");

require("core-js/modules/es.typed-array.reduce.js");

require("core-js/modules/es.typed-array.reduce-right.js");

require("core-js/modules/es.typed-array.reverse.js");

require("core-js/modules/es.typed-array.set.js");

require("core-js/modules/es.typed-array.slice.js");

require("core-js/modules/es.typed-array.some.js");

require("core-js/modules/es.typed-array.sort.js");

require("core-js/modules/es.typed-array.subarray.js");

require("core-js/modules/es.typed-array.to-locale-string.js");

require("core-js/modules/es.typed-array.to-string.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.array.map.js");

require("core-js/modules/es.string.trim.js");

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.object.keys.js");

require("core-js/modules/es.array.filter.js");

require("core-js/modules/es.object.get-own-property-descriptor.js");

require("core-js/modules/web.dom-collections.for-each.js");

require("core-js/modules/es.object.get-own-property-descriptors.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.object.get-prototype-of.js");

require("core-js/modules/es.reflect.construct.js");

require("core-js/modules/es.reflect.get.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.function.name.js");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});

var axios = require('axios');

var tweetnacl = require('tweetnacl');

function _interopDefaultLegacy(e) {
  return e && _typeof(e) === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
/** Converts a Uint8Array to a hexadecimal string. */


function uint8arrayToHex(array) {
  return Buffer.from(array).toString("hex");
}
/**
 * Generates an account with a 32-bit account number and signing key.
 * @returns the generated account
 */


function createAccountData() {
  var keyPair = tweetnacl.sign.keyPair();
  var publicKey = keyPair.publicKey,
      signingKey = keyPair.secretKey;
  var publicKeyHex = uint8arrayToHex(publicKey);
  var signingKeyHex = uint8arrayToHex(signingKey);
  return {
    publicKey: publicKey,
    publicKeyHex: publicKeyHex,
    signingKey: signingKey,
    signingKeyHex: signingKeyHex.replace(publicKeyHex, "")
  };
}
/**
 * Formats the options for server nodes.
 * @param options the object for the server node options
 */


function formatDefaultOptions(options) {
  /*
      Default Options should look like:
      {
        defaultPagination: {
          limit: 20,
          offset: 0
        }
      }
      but also allow re-writes to the `defaultPagination` key while having all keys.
    */
  return _objectSpread(_objectSpread({}, options), {}, {
    defaultPagination: _objectSpread({
      limit: 20,
      offset: 0
    }, options.defaultPagination || {})
  });
}
/**
 * Normalizes a url for requests to be made with.
 * @param url the url string that must include the protocol (https, http, ect.) of the requests
 */


function formatUrl(url) {
  var _URL = new URL(url),
      protocol = _URL.protocol,
      host = _URL.host;

  return "".concat(protocol !== null && protocol !== void 0 ? protocol : "http", "//").concat(host);
}

function hexToUint8Array(arr) {
  return new Uint8Array(Buffer.from(arr, "hex"));
}

function throwError(description, error) {
  var message = "Error(thenewboston-js): ".concat(description);

  if (error) {
    message += "Further details may be provided below:\n".concat(error);
  }

  throw Error(message);
}

var TransferDetails = function TransferDetails(sender, recipient, amount, memo) {
  _classCallCheck(this, TransferDetails);

  this.sender = sender;
  this.recipient = recipient;
  this.amount = amount;
  this.memo = memo;
};
/**
 * Used internally for all server nodes.
 *
 * Note: this class is meant to be extended.
 */


var ServerNode = /*#__PURE__*/function () {
  function ServerNode(url) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ServerNode);

    this.url = formatUrl(url);
    this.options = formatDefaultOptions(options);
  }
  /**
   * Gets data for the given endpoint with the given query params.
   * @param endpoint the endpoint to send the request to
   * @param params the optional object for the query params
   */


  _createClass(ServerNode, [{
    key: "getData",
    value: function () {
      var _getData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(endpoint) {
        var params,
            res,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                params = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return axios__default['default'].get("".concat(this.url).concat(endpoint), {
                  params: params
                });

              case 3:
                res = _context.sent;
                return _context.abrupt("return", res.data);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getData(_x) {
        return _getData.apply(this, arguments);
      }

      return getData;
    }()
    /**
     * Used internally for handling paginated requests.
     * @param endpoint the endpoint to send the request to
     * @param options the optional object for the pagination options
     */

  }, {
    key: "getPaginatedData",
    value: function () {
      var _getPaginatedData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(endpoint, options) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getData(endpoint, _objectSpread(_objectSpread({}, this.options.defaultPagination), options));

              case 2:
                return _context2.abrupt("return", _context2.sent);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getPaginatedData(_x2, _x3) {
        return _getPaginatedData.apply(this, arguments);
      }

      return getPaginatedData;
    }()
    /**
     * Sends a POST request to the current server with the given `data`.
     * @param endpoint the endpoint to send the request to
     * @param data what is sent along with the POST request
     */

  }, {
    key: "postData",
    value: function () {
      var _postData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(endpoint, data) {
        var res;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return axios__default['default'].post("".concat(this.url).concat(endpoint), data).catch(function (err) {
                  console.log(err.response.data);
                  throwError("Failed to postData:", err);
                });

              case 2:
                res = _context3.sent;
                return _context3.abrupt("return", res.data);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function postData(_x4, _x5) {
        return _postData.apply(this, arguments);
      }

      return postData;
    }()
    /**
     * Sends a PATCH request to the current server with the given `data`.
     * @param endpoint the endpoint to send the request to
     * @param data what is sent along with the PATCH request
     */

  }, {
    key: "patchData",
    value: function () {
      var _patchData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(endpoint, data) {
        var res;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return axios__default['default'].patch("".concat(this.url).concat(endpoint), data);

              case 2:
                res = _context4.sent;
                return _context4.abrupt("return", res.data);

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function patchData(_x6, _x7) {
        return _patchData.apply(this, arguments);
      }

      return patchData;
    }()
    /**
     * Gets the accounts for the given server node in a paginated format.
     * @param options The optional object for the pagination options.
     */

  }, {
    key: "getAccounts",
    value: function () {
      var _getAccounts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var options,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};
                _context5.next = 3;
                return this.getPaginatedData("/accounts", options);

              case 3:
                return _context5.abrupt("return", _context5.sent);

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getAccounts() {
        return _getAccounts.apply(this, arguments);
      }

      return getAccounts;
    }()
    /** Gets the current config data for the current validator. */

  }, {
    key: "_getConfig",
    value: function () {
      var _getConfig2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getData("/config");

              case 2:
                return _context6.abrupt("return", _context6.sent);

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _getConfig() {
        return _getConfig2.apply(this, arguments);
      }

      return _getConfig;
    }()
    /**
     * Sends a connection request to this current network with the data about the new server.
     * @param ipAddress the new server node's ip address
     * @param port the new node's port
     * @param protocol the new node's protocol
     * @param account the server account to validate the request
     */

  }, {
    key: "sendConnectionRequest",
    value: function () {
      var _sendConnectionRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(ipAddress, port, protocol, account) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.postData("/connection_requests", account.createSignedMessage({
                  ip_address: ipAddress,
                  port: port,
                  protocol: protocol
                }));

              case 2:
                return _context7.abrupt("return", _context7.sent);

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function sendConnectionRequest(_x8, _x9, _x10, _x11) {
        return _sendConnectionRequest.apply(this, arguments);
      }

      return sendConnectionRequest;
    }()
  }]);

  return ServerNode;
}();
/**
 * Used as a base for all types of validator nodes.
 *
 * Note: this class is meant to be extended.
 */


var Validator = /*#__PURE__*/function (_ServerNode) {
  _inherits(Validator, _ServerNode);

  var _super = _createSuper(Validator);

  function Validator() {
    _classCallCheck(this, Validator);

    return _super.apply(this, arguments);
  }

  _createClass(Validator, [{
    key: "getBank",
    value:
    /**
     * Gets the bank with the specified node identifier.
     * @param nodeIdentifier Node Identifier of a bank.
     */
    function () {
      var _getBank = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(nodeIdentifier) {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return _get(_getPrototypeOf(Validator.prototype), "getData", this).call(this, "/banks/".concat(nodeIdentifier));

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getBank(_x12) {
        return _getBank.apply(this, arguments);
      }

      return getBank;
    }()
    /** Gets all of the banks connected to the current validator. */

  }, {
    key: "getBanks",
    value: function () {
      var _getBanks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var options,
            _args9 = arguments;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                options = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : {};
                _context9.next = 3;
                return _get(_getPrototypeOf(Validator.prototype), "getPaginatedData", this).call(this, "/banks", options);

              case 3:
                return _context9.abrupt("return", _context9.sent);

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getBanks() {
        return _getBanks.apply(this, arguments);
      }

      return getBanks;
    }()
    /**
     * Gets the account balance with the given account number (id).
     * @param accountNumber the public key of the account
     */

  }, {
    key: "getAccountBalance",
    value: function () {
      var _getAccountBalance = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(accountNumber) {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return _get(_getPrototypeOf(Validator.prototype), "getData", this).call(this, "/accounts/".concat(accountNumber, "/balance"));

              case 2:
                return _context10.abrupt("return", _context10.sent);

              case 3:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getAccountBalance(_x13) {
        return _getAccountBalance.apply(this, arguments);
      }

      return getAccountBalance;
    }()
    /**
     * Gets the balance lock of the given account.
     * @param accountNumber the public key of the account
     */

  }, {
    key: "getAccountBalanceLock",
    value: function () {
      var _getAccountBalanceLock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(accountNumber) {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return _get(_getPrototypeOf(Validator.prototype), "getData", this).call(this, "/accounts/".concat(accountNumber, "/balance_lock"));

              case 2:
                return _context11.abrupt("return", _context11.sent);

              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getAccountBalanceLock(_x14) {
        return _getAccountBalanceLock.apply(this, arguments);
      }

      return getAccountBalanceLock;
    }()
    /**
     * Gets the details of given block identifier's queued transactions.
     * @param blockId the block identifier
     */

  }, {
    key: "getQueuedConfirmationBlock",
    value: function () {
      var _getQueuedConfirmationBlock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(blockId) {
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return _get(_getPrototypeOf(Validator.prototype), "getData", this).call(this, "/confirmation_blocks/".concat(blockId, "/queued"));

              case 2:
                return _context12.abrupt("return", _context12.sent);

              case 3:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getQueuedConfirmationBlock(_x15) {
        return _getQueuedConfirmationBlock.apply(this, arguments);
      }

      return getQueuedConfirmationBlock;
    }()
    /**
     * Gets the details of given block identifier's valid transactions.
     * @param blockId the block identifier
     */

  }, {
    key: "getValidConfirmationBlock",
    value: function () {
      var _getValidConfirmationBlock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(blockId) {
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return _get(_getPrototypeOf(Validator.prototype), "getData", this).call(this, "/confirmation_blocks/".concat(blockId, "/valid"));

              case 2:
                return _context13.abrupt("return", _context13.sent);

              case 3:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getValidConfirmationBlock(_x16) {
        return _getValidConfirmationBlock.apply(this, arguments);
      }

      return getValidConfirmationBlock;
    }()
    /**
     * Gets the validator with the specified node identifier.
     * @param nodeIdentifier Node Identifier of a validator.
     */

  }, {
    key: "getValidator",
    value: function () {
      var _getValidator = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(nodeIdentifier) {
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return _get(_getPrototypeOf(Validator.prototype), "getData", this).call(this, "/validators/".concat(nodeIdentifier));

              case 2:
                return _context14.abrupt("return", _context14.sent);

              case 3:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getValidator(_x17) {
        return _getValidator.apply(this, arguments);
      }

      return getValidator;
    }()
    /**
     * Gets all of the connected validators to the current validator.
     * @param options the pagination options
     */

  }, {
    key: "getValidators",
    value: function () {
      var _getValidators = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
        var options,
            _args15 = arguments;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                options = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : {};
                _context15.next = 3;
                return _get(_getPrototypeOf(Validator.prototype), "getPaginatedData", this).call(this, "/validators", options);

              case 3:
                return _context15.abrupt("return", _context15.sent);

              case 4:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getValidators() {
        return _getValidators.apply(this, arguments);
      }

      return getValidators;
    }()
    /**
     * Updates a given bank's trust.
     * @param nodeIdentifier the bank to update's node identifier
     * @param trust the new bank's trust
     * @param account the current validators's network Id to sign the request
     */

  }, {
    key: "updateBankTrust",
    value: function () {
      var _updateBankTrust = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(nodeIdentifier, trust, account) {
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return _get(_getPrototypeOf(Validator.prototype), "patchData", this).call(this, "/banks/".concat(nodeIdentifier), account.createSignedMessage({
                  trust: trust
                }));

              case 2:
                return _context16.abrupt("return", _context16.sent);

              case 3:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function updateBankTrust(_x18, _x19, _x20) {
        return _updateBankTrust.apply(this, arguments);
      }

      return updateBankTrust;
    }()
    /**
     * Updates a given validators's trust.
     * @param nodeIdentifier the validator to update's node identifier
     * @param trust the new validator's trust
     * @param account the current validators's network Id to sign the request
     */

  }, {
    key: "updateValidatorTrust",
    value: function () {
      var _updateValidatorTrust = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(nodeIdentifier, trust, account) {
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return _get(_getPrototypeOf(Validator.prototype), "patchData", this).call(this, "/validators/".concat(nodeIdentifier), account.createSignedMessage({
                  trust: trust
                }));

              case 2:
                return _context17.abrupt("return", _context17.sent);

              case 3:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function updateValidatorTrust(_x21, _x22, _x23) {
        return _updateValidatorTrust.apply(this, arguments);
      }

      return updateValidatorTrust;
    }()
  }]);

  return Validator;
}(ServerNode);
/** Used for connecting with and using primary validator server nodes. */


var PrimaryValidator = /*#__PURE__*/function (_Validator) {
  _inherits(PrimaryValidator, _Validator);

  var _super2 = _createSuper(PrimaryValidator);

  function PrimaryValidator() {
    _classCallCheck(this, PrimaryValidator);

    return _super2.apply(this, arguments);
  }

  _createClass(PrimaryValidator, [{
    key: "getConfig",
    value:
    /** Gets the config of the current primary validator server. */
    function () {
      var _getConfig3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                return _context18.abrupt("return", _get(_getPrototypeOf(PrimaryValidator.prototype), "_getConfig", this).call(this));

              case 1:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getConfig() {
        return _getConfig3.apply(this, arguments);
      }

      return getConfig;
    }()
    /**
     * Bank blocks would need to be signed by the bank indicating tha the block has passed the validation.
     * @param balanceLock the current balance lock
     * @param transactions the transactions to push to the block chain
     * @param account the account that is sending the transactions
     */

  }, {
    key: "addBankBlocks",
    value: function () {
      var _addBankBlocks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(balanceLock, transactions, account) {
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.postData("/bank_blocks", account.createBlockMessage(balanceLock, transactions));

              case 2:
                return _context19.abrupt("return", _context19.sent);

              case 3:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function addBankBlocks(_x24, _x25, _x26) {
        return _addBankBlocks.apply(this, arguments);
      }

      return addBankBlocks;
    }()
    /**
     * Get transaction fee of the current Primary Validator
     */

  }, {
    key: "getTxFee",
    value: function () {
      var _getTxFee = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getConfig();

              case 2:
                return _context20.abrupt("return", _context20.sent.default_transaction_fee);

              case 3:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getTxFee() {
        return _getTxFee.apply(this, arguments);
      }

      return getTxFee;
    }()
  }]);

  return PrimaryValidator;
}(Validator);
/** Used for creating banks and sending requests easily to that specific bank server node. */


var Bank = /*#__PURE__*/function (_ServerNode2) {
  _inherits(Bank, _ServerNode2);

  var _super3 = _createSuper(Bank);

  function Bank() {
    _classCallCheck(this, Bank);

    return _super3.apply(this, arguments);
  }

  _createClass(Bank, [{
    key: "updateAccountTrust",
    value:
    /**
     * Updates the given server account's trust on the bank.
     * @param accountNumber the account number of the server to update
     * @param trust the trust of the the server
     * @param account the account for the server node in which the account number is the node identifier and the signing key is the node identifier signing key
     */
    function () {
      var _updateAccountTrust = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(accountNumber, trust, account) {
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "patchData", this).call(this, "/accounts/".concat(accountNumber), account.createSignedMessage({
                  trust: trust
                }));

              case 2:
                return _context21.abrupt("return", _context21.sent);

              case 3:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function updateAccountTrust(_x27, _x28, _x29) {
        return _updateAccountTrust.apply(this, arguments);
      }

      return updateAccountTrust;
    }()
    /**
     * Gets the transactions for the given bank.
     * @param options The optional object for the pagination options.
     */

  }, {
    key: "getTransactions",
    value: function () {
      var _getTransactions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22() {
        var options,
            _args22 = arguments;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                options = _args22.length > 0 && _args22[0] !== undefined ? _args22[0] : {};
                _context22.next = 3;
                return _get(_getPrototypeOf(Bank.prototype), "getPaginatedData", this).call(this, "/bank_transactions", options);

              case 3:
                return _context22.abrupt("return", _context22.sent);

              case 4:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getTransactions() {
        return _getTransactions.apply(this, arguments);
      }

      return getTransactions;
    }()
    /**
     * Gets the bank with the specified node identifier.
     * @param nodeIdentifier Node Identifier of a bank.
     */

  }, {
    key: "getBank",
    value: function () {
      var _getBank2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(nodeIdentifier) {
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "getData", this).call(this, "/banks/".concat(nodeIdentifier));

              case 2:
                return _context23.abrupt("return", _context23.sent);

              case 3:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getBank(_x30) {
        return _getBank2.apply(this, arguments);
      }

      return getBank;
    }()
    /**
     * Gets the connected banks for the given bank.
     * @param options The optional object for the pagination options.
     */

  }, {
    key: "getBanks",
    value: function () {
      var _getBanks2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24() {
        var options,
            _args24 = arguments;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                options = _args24.length > 0 && _args24[0] !== undefined ? _args24[0] : {};
                _context24.next = 3;
                return _get(_getPrototypeOf(Bank.prototype), "getPaginatedData", this).call(this, "/banks", options);

              case 3:
                return _context24.abrupt("return", _context24.sent);

              case 4:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getBanks() {
        return _getBanks2.apply(this, arguments);
      }

      return getBanks;
    }()
    /**
     * Updates a given bank's trust.
     * @param nodeIdentifier the bank to update's node identifier
     * @param trust the new bank's trust
     * @param account the account to sign the request
     */

  }, {
    key: "updateBankTrust",
    value: function () {
      var _updateBankTrust2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(nodeIdentifier, trust, account) {
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "patchData", this).call(this, "/banks/".concat(nodeIdentifier), account.createSignedMessage({
                  trust: trust
                }));

              case 2:
                return _context25.abrupt("return", _context25.sent);

              case 3:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function updateBankTrust(_x31, _x32, _x33) {
        return _updateBankTrust2.apply(this, arguments);
      }

      return updateBankTrust;
    }()
    /**
     * Updates a given validators's trust.
     * @param nodeIdentifier the validator to update's node identifier
     * @param trust the new validator's trust
     * @param account the current bank's network Id to sign the request
     */

  }, {
    key: "updateValidatorTrust",
    value: function () {
      var _updateValidatorTrust2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(nodeIdentifier, trust, account) {
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "patchData", this).call(this, "/validators/".concat(nodeIdentifier), account.createSignedMessage({
                  trust: trust
                }));

              case 2:
                return _context26.abrupt("return", _context26.sent);

              case 3:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function updateValidatorTrust(_x34, _x35, _x36) {
        return _updateValidatorTrust2.apply(this, arguments);
      }

      return updateValidatorTrust;
    }()
    /**
     * Gets the blocks for the given bank.
     * @param options The optional object for the pagination options.
     */

  }, {
    key: "getBlocks",
    value: function () {
      var _getBlocks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27() {
        var options,
            _args27 = arguments;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                options = _args27.length > 0 && _args27[0] !== undefined ? _args27[0] : {};
                _context27.next = 3;
                return _get(_getPrototypeOf(Bank.prototype), "getPaginatedData", this).call(this, "/blocks", options);

              case 3:
                return _context27.abrupt("return", _context27.sent);

              case 4:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getBlocks() {
        return _getBlocks.apply(this, arguments);
      }

      return getBlocks;
    }()
    /**
     * Adds new transaction blocks to the blockchain.
     * @param balanceLock the current balance lock
     * @param transactions the transactions to push to the block chain
     * @param account the account that is sending the transactions
     */

  }, {
    key: "addBlocks",
    value: function () {
      var _addBlocks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(balanceLock, transactions, account) {
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "postData", this).call(this, "/blocks", account.createBlockMessage(balanceLock, transactions));

              case 2:
                return _context28.abrupt("return", _context28.sent);

              case 3:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function addBlocks(_x37, _x38, _x39) {
        return _addBlocks.apply(this, arguments);
      }

      return addBlocks;
    }()
    /**
     * Gets the current bank's config data.
     */

  }, {
    key: "getConfig",
    value: function () {
      var _getConfig4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29() {
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "getData", this).call(this, "/config");

              case 2:
                return _context29.abrupt("return", _context29.sent);

              case 3:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getConfig() {
        return _getConfig4.apply(this, arguments);
      }

      return getConfig;
    }()
    /** Gets the current crawl status */

  }, {
    key: "getCrawlStatus",
    value: function () {
      var _getCrawlStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30() {
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "getData", this).call(this, "/crawl");

              case 2:
                return _context30.abrupt("return", _context30.sent);

              case 3:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getCrawlStatus() {
        return _getCrawlStatus.apply(this, arguments);
      }

      return getCrawlStatus;
    }()
    /**
     * Sends a Post Request to the bank to start crawl process
     * @param account An Account created with the Network Id Signing key of the current Bank
     */

  }, {
    key: "startCrawl",
    value: function () {
      var _startCrawl = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(account) {
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                _context31.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "postData", this).call(this, "/crawl", account.createSignedMessage({
                  crawl: "start"
                }));

              case 2:
                return _context31.abrupt("return", _context31.sent);

              case 3:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function startCrawl(_x40) {
        return _startCrawl.apply(this, arguments);
      }

      return startCrawl;
    }()
    /**
     * Sends a Post Request to the bank to start crawl process
     * @param account An Account created with the Network Id Signing key of the current Bank
     */

  }, {
    key: "stopCrawl",
    value: function () {
      var _stopCrawl = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(account) {
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "postData", this).call(this, "/crawl", account.createSignedMessage({
                  crawl: "stop"
                }));

              case 2:
                return _context32.abrupt("return", _context32.sent);

              case 3:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function stopCrawl(_x41) {
        return _stopCrawl.apply(this, arguments);
      }

      return stopCrawl;
    }()
    /** Gets the current clean status */

  }, {
    key: "getCleanStatus",
    value: function () {
      var _getCleanStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33() {
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                _context33.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "getData", this).call(this, "/clean");

              case 2:
                return _context33.abrupt("return", _context33.sent);

              case 3:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getCleanStatus() {
        return _getCleanStatus.apply(this, arguments);
      }

      return getCleanStatus;
    }()
    /**
     * Sends a Post Request to the bank to start clean process
     * @param account An Account created with the Network Id Signing key of the current Bank
     */

  }, {
    key: "startClean",
    value: function () {
      var _startClean = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(account) {
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                _context34.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "postData", this).call(this, "/clean", account.createSignedMessage({
                  clean: "start"
                }));

              case 2:
                return _context34.abrupt("return", _context34.sent);

              case 3:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function startClean(_x42) {
        return _startClean.apply(this, arguments);
      }

      return startClean;
    }()
    /**
     * Sends a Post Request to the bank to start clean process
     * @param account An Account created with the Network Id Signing key of the current Bank
     */

  }, {
    key: "stopClean",
    value: function () {
      var _stopClean = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(account) {
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                _context35.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "postData", this).call(this, "/clean", account.createSignedMessage({
                  clean: "stop"
                }));

              case 2:
                return _context35.abrupt("return", _context35.sent);

              case 3:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function stopClean(_x43) {
        return _stopClean.apply(this, arguments);
      }

      return stopClean;
    }()
    /**
     * Gets the confirmation blocks for the given bank.
     * @param options The optional object for the pagination options.
     */

  }, {
    key: "getConfirmationBlocks",
    value: function () {
      var _getConfirmationBlocks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36() {
        var options,
            _args36 = arguments;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                options = _args36.length > 0 && _args36[0] !== undefined ? _args36[0] : {};
                _context36.next = 3;
                return _get(_getPrototypeOf(Bank.prototype), "getPaginatedData", this).call(this, "/confirmation_blocks", options);

              case 3:
                return _context36.abrupt("return", _context36.sent);

              case 4:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function getConfirmationBlocks() {
        return _getConfirmationBlocks.apply(this, arguments);
      }

      return getConfirmationBlocks;
    }() // TODO: POST /confirmation_blocks

    /**
     * Gets the invalid blocks for the given bank.
     * @param options The optional object for the pagination options.
     */

  }, {
    key: "getInvalidBlocks",
    value: function () {
      var _getInvalidBlocks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37() {
        var options,
            _args37 = arguments;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                options = _args37.length > 0 && _args37[0] !== undefined ? _args37[0] : {};
                _context37.next = 3;
                return _get(_getPrototypeOf(Bank.prototype), "getPaginatedData", this).call(this, "/invalid_blocks", options);

              case 3:
                return _context37.abrupt("return", _context37.sent);

              case 4:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function getInvalidBlocks() {
        return _getInvalidBlocks.apply(this, arguments);
      }

      return getInvalidBlocks;
    }()
    /**
     * Gets the validator confirmation services for the given bank.
     * @param options The optional object for the pagination options.
     */

  }, {
    key: "getValidatorConfirmationServices",
    value: function () {
      var _getValidatorConfirmationServices = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38() {
        var options,
            _args38 = arguments;
        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                options = _args38.length > 0 && _args38[0] !== undefined ? _args38[0] : {};
                _context38.next = 3;
                return _get(_getPrototypeOf(Bank.prototype), "getPaginatedData", this).call(this, "/validator_confirmation_services", options);

              case 3:
                return _context38.abrupt("return", _context38.sent);

              case 4:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function getValidatorConfirmationServices() {
        return _getValidatorConfirmationServices.apply(this, arguments);
      }

      return getValidatorConfirmationServices;
    }()
    /**
     * Updates the validator's confirmation services data.
     * @param start the validator's services start date
     * @param end the validator's services end date
     * @param account the server's account to validate the requests
     */

  }, {
    key: "updateValidatorConfirmationServices",
    value: function () {
      var _updateValidatorConfirmationServices = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(start, end, account) {
        return regeneratorRuntime.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                _context39.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "postData", this).call(this, "/validator_confirmation_services", account.createSignedMessage({
                  start: start,
                  end: end
                }));

              case 2:
                return _context39.abrupt("return", _context39.sent);

              case 3:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));

      function updateValidatorConfirmationServices(_x44, _x45, _x46) {
        return _updateValidatorConfirmationServices.apply(this, arguments);
      }

      return updateValidatorConfirmationServices;
    }()
    /**
     * Sends a signed POST request to the bank for an upgrade notice.
     * @param nodeIdentifier the node identifier of the bank that is receiving the upgrade notice
     * @param account the current bank server's account
     */

  }, {
    key: "sendUpgradeNotice",
    value: function () {
      var _sendUpgradeNotice = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee40(nodeIdentifier, account) {
        return regeneratorRuntime.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                _context40.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "postData", this).call(this, "/upgrade_notice", account.createSignedMessage({
                  bank_node_identifier: nodeIdentifier
                }));

              case 2:
                return _context40.abrupt("return", _context40.sent);

              case 3:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));

      function sendUpgradeNotice(_x47, _x48) {
        return _sendUpgradeNotice.apply(this, arguments);
      }

      return sendUpgradeNotice;
    }()
    /**
     * Gets the validator with the specified node identifier.
     * @param nodeIdentifier Node Identifier of a validator.
     */

  }, {
    key: "getValidator",
    value: function () {
      var _getValidator2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(nodeIdentifier) {
        return regeneratorRuntime.wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                _context41.next = 2;
                return _get(_getPrototypeOf(Bank.prototype), "getData", this).call(this, "/validators/".concat(nodeIdentifier));

              case 2:
                return _context41.abrupt("return", _context41.sent);

              case 3:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));

      function getValidator(_x49) {
        return _getValidator2.apply(this, arguments);
      }

      return getValidator;
    }()
    /**
     * Gets all of the validators for the current bank.
     * @param options The optional object for the pagination options.
     */

  }, {
    key: "getValidators",
    value: function () {
      var _getValidators2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee42() {
        var options,
            _args42 = arguments;
        return regeneratorRuntime.wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                options = _args42.length > 0 && _args42[0] !== undefined ? _args42[0] : {};
                _context42.next = 3;
                return _get(_getPrototypeOf(Bank.prototype), "getPaginatedData", this).call(this, "/validators", options);

              case 3:
                return _context42.abrupt("return", _context42.sent);

              case 4:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));

      function getValidators() {
        return _getValidators2.apply(this, arguments);
      }

      return getValidators;
    }()
    /**
     * Gets the PrimaryValidator for the current bank.
     */

  }, {
    key: "getBankPV",
    value: function () {
      var _getBankPV = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee43() {
        var _yield$this$getConfig, primary_validator;

        return regeneratorRuntime.wrap(function _callee43$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                _context43.next = 2;
                return this.getConfig();

              case 2:
                _yield$this$getConfig = _context43.sent;
                primary_validator = _yield$this$getConfig.primary_validator;
                return _context43.abrupt("return", new PrimaryValidator("".concat(primary_validator.protocol, "://").concat(primary_validator.ip_address).concat(primary_validator.port === null ? "" : ":" + primary_validator.port)));

              case 5:
              case "end":
                return _context43.stop();
            }
          }
        }, _callee43, this);
      }));

      function getBankPV() {
        return _getBankPV.apply(this, arguments);
      }

      return getBankPV;
    }()
    /**
     * Get transaction fee of the current Primary Validator
     */

  }, {
    key: "getTxFee",
    value: function () {
      var _getTxFee2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee44() {
        return regeneratorRuntime.wrap(function _callee44$(_context44) {
          while (1) {
            switch (_context44.prev = _context44.next) {
              case 0:
                _context44.next = 2;
                return this.getConfig();

              case 2:
                return _context44.abrupt("return", _context44.sent.default_transaction_fee);

              case 3:
              case "end":
                return _context44.stop();
            }
          }
        }, _callee44, this);
      }));

      function getTxFee() {
        return _getTxFee2.apply(this, arguments);
      }

      return getTxFee;
    }()
  }]);

  return Bank;
}(ServerNode);
/** Used for connecting with and using confirmation validator server nodes. */


var ConfirmationValidator = /*#__PURE__*/function (_Validator2) {
  _inherits(ConfirmationValidator, _Validator2);

  var _super4 = _createSuper(ConfirmationValidator);

  function ConfirmationValidator() {
    _classCallCheck(this, ConfirmationValidator);

    return _super4.apply(this, arguments);
  }

  _createClass(ConfirmationValidator, [{
    key: "getBankConfirmationServices",
    value:
    /** Gets the current confirmation confirmation validator's listed services. */
    function () {
      var _getBankConfirmationServices = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee45() {
        var options,
            _args45 = arguments;
        return regeneratorRuntime.wrap(function _callee45$(_context45) {
          while (1) {
            switch (_context45.prev = _context45.next) {
              case 0:
                options = _args45.length > 0 && _args45[0] !== undefined ? _args45[0] : {};
                _context45.next = 3;
                return _get(_getPrototypeOf(ConfirmationValidator.prototype), "getPaginatedData", this).call(this, "/bank_confirmation_services", options);

              case 3:
                return _context45.abrupt("return", _context45.sent);

              case 4:
              case "end":
                return _context45.stop();
            }
          }
        }, _callee45, this);
      }));

      function getBankConfirmationServices() {
        return _getBankConfirmationServices.apply(this, arguments);
      }

      return getBankConfirmationServices;
    }()
    /** Gets the current crawl status */

  }, {
    key: "getCrawlStatus",
    value: function () {
      var _getCrawlStatus2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee46() {
        return regeneratorRuntime.wrap(function _callee46$(_context46) {
          while (1) {
            switch (_context46.prev = _context46.next) {
              case 0:
                _context46.next = 2;
                return _get(_getPrototypeOf(ConfirmationValidator.prototype), "getData", this).call(this, "/crawl");

              case 2:
                return _context46.abrupt("return", _context46.sent);

              case 3:
              case "end":
                return _context46.stop();
            }
          }
        }, _callee46, this);
      }));

      function getCrawlStatus() {
        return _getCrawlStatus2.apply(this, arguments);
      }

      return getCrawlStatus;
    }()
    /**
     * Sends a Post Request to the confirmation validator to start crawl process
     * @param account An Account created with the Network Id Signing key of the current Confirmation Validator
     */

  }, {
    key: "startCrawl",
    value: function () {
      var _startCrawl2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee47(account) {
        return regeneratorRuntime.wrap(function _callee47$(_context47) {
          while (1) {
            switch (_context47.prev = _context47.next) {
              case 0:
                _context47.next = 2;
                return _get(_getPrototypeOf(ConfirmationValidator.prototype), "postData", this).call(this, "/crawl", account.createSignedMessage({
                  crawl: "start"
                }));

              case 2:
                return _context47.abrupt("return", _context47.sent);

              case 3:
              case "end":
                return _context47.stop();
            }
          }
        }, _callee47, this);
      }));

      function startCrawl(_x50) {
        return _startCrawl2.apply(this, arguments);
      }

      return startCrawl;
    }()
    /**
     * Sends a Post Request to the confirmation validator to start crawl process
     * @param account An Account created with the Network Id Signing key of the current Confirmation Validator
     */

  }, {
    key: "stopCrawl",
    value: function () {
      var _stopCrawl2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee48(account) {
        return regeneratorRuntime.wrap(function _callee48$(_context48) {
          while (1) {
            switch (_context48.prev = _context48.next) {
              case 0:
                _context48.next = 2;
                return _get(_getPrototypeOf(ConfirmationValidator.prototype), "postData", this).call(this, "/crawl", account.createSignedMessage({
                  crawl: "stop"
                }));

              case 2:
                return _context48.abrupt("return", _context48.sent);

              case 3:
              case "end":
                return _context48.stop();
            }
          }
        }, _callee48, this);
      }));

      function stopCrawl(_x51) {
        return _stopCrawl2.apply(this, arguments);
      }

      return stopCrawl;
    }()
    /** Gets the current clean status */

  }, {
    key: "getCleanStatus",
    value: function () {
      var _getCleanStatus2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee49() {
        return regeneratorRuntime.wrap(function _callee49$(_context49) {
          while (1) {
            switch (_context49.prev = _context49.next) {
              case 0:
                _context49.next = 2;
                return _get(_getPrototypeOf(ConfirmationValidator.prototype), "getData", this).call(this, "/clean");

              case 2:
                return _context49.abrupt("return", _context49.sent);

              case 3:
              case "end":
                return _context49.stop();
            }
          }
        }, _callee49, this);
      }));

      function getCleanStatus() {
        return _getCleanStatus2.apply(this, arguments);
      }

      return getCleanStatus;
    }()
    /**
     * Sends a Post Request to the confirmation validator to start clean process
     * @param account An Account created with the Network Id Signing key of the current Confirmation Validator
     */

  }, {
    key: "startClean",
    value: function () {
      var _startClean2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee50(account) {
        return regeneratorRuntime.wrap(function _callee50$(_context50) {
          while (1) {
            switch (_context50.prev = _context50.next) {
              case 0:
                _context50.next = 2;
                return _get(_getPrototypeOf(ConfirmationValidator.prototype), "postData", this).call(this, "/clean", account.createSignedMessage({
                  clean: "start"
                }));

              case 2:
                return _context50.abrupt("return", _context50.sent);

              case 3:
              case "end":
                return _context50.stop();
            }
          }
        }, _callee50, this);
      }));

      function startClean(_x52) {
        return _startClean2.apply(this, arguments);
      }

      return startClean;
    }()
    /**
     * Sends a Post Request to the confirmation validator to start clean process
     * @param account An Account created with the Network Id Signing key of the current Confirmation Validator
     */

  }, {
    key: "stopClean",
    value: function () {
      var _stopClean2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee51(account) {
        return regeneratorRuntime.wrap(function _callee51$(_context51) {
          while (1) {
            switch (_context51.prev = _context51.next) {
              case 0:
                _context51.next = 2;
                return _get(_getPrototypeOf(ConfirmationValidator.prototype), "postData", this).call(this, "/clean", account.createSignedMessage({
                  clean: "stop"
                }));

              case 2:
                return _context51.abrupt("return", _context51.sent);

              case 3:
              case "end":
                return _context51.stop();
            }
          }
        }, _callee51, this);
      }));

      function stopClean(_x53) {
        return _stopClean2.apply(this, arguments);
      }

      return stopClean;
    }() // TODO: POST /confirmation_blocks

    /**
     * Sends a notification to the bank that a primary validator has left the network.
     * @param ipAddress the ip address of the primary validator that is leaving
     * @param port the port that the primary validator is on
     * @param protocol the protocol of the primary validator
     * @param account the account that the current `ConfirmationValidator` is connected to
     */

  }, {
    key: "sendPrimaryValidatorUpdatedPing",
    value: function () {
      var _sendPrimaryValidatorUpdatedPing = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee52(ipAddress, port, protocol, account) {
        return regeneratorRuntime.wrap(function _callee52$(_context52) {
          while (1) {
            switch (_context52.prev = _context52.next) {
              case 0:
                _context52.next = 2;
                return _get(_getPrototypeOf(ConfirmationValidator.prototype), "postData", this).call(this, "/primary_validator_updated", account.createSignedMessage({
                  ip_address: ipAddress,
                  port: port,
                  protocol: protocol
                }));

              case 2:
                return _context52.abrupt("return", _context52.sent);

              case 3:
              case "end":
                return _context52.stop();
            }
          }
        }, _callee52, this);
      }));

      function sendPrimaryValidatorUpdatedPing(_x54, _x55, _x56, _x57) {
        return _sendPrimaryValidatorUpdatedPing.apply(this, arguments);
      }

      return sendPrimaryValidatorUpdatedPing;
    }()
    /**
     * Sends a signed POST request to the confirmation validator for an upgrade request.
     * @param nodeIdentifier the node identifier of the confirmation validator that is receiving the upgrade notice
     * @param account the current confirmation validator server's account
     */

  }, {
    key: "sendUpgradeRequest",
    value: function () {
      var _sendUpgradeRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee53(nodeIdentifier, account) {
        return regeneratorRuntime.wrap(function _callee53$(_context53) {
          while (1) {
            switch (_context53.prev = _context53.next) {
              case 0:
                _context53.next = 2;
                return _get(_getPrototypeOf(ConfirmationValidator.prototype), "postData", this).call(this, "/upgrade_request", account.createSignedMessage({
                  validator_node_identifier: nodeIdentifier
                }));

              case 2:
                return _context53.abrupt("return", _context53.sent);

              case 3:
              case "end":
                return _context53.stop();
            }
          }
        }, _callee53, this);
      }));

      function sendUpgradeRequest(_x58, _x59) {
        return _sendUpgradeRequest.apply(this, arguments);
      }

      return sendUpgradeRequest;
    }()
    /** Gets the current confirmation validator's config data. */

  }, {
    key: "getConfig",
    value: function () {
      var _getConfig5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee54() {
        return regeneratorRuntime.wrap(function _callee54$(_context54) {
          while (1) {
            switch (_context54.prev = _context54.next) {
              case 0:
                return _context54.abrupt("return", _get(_getPrototypeOf(ConfirmationValidator.prototype), "_getConfig", this).call(this));

              case 1:
              case "end":
                return _context54.stop();
            }
          }
        }, _callee54, this);
      }));

      function getConfig() {
        return _getConfig5.apply(this, arguments);
      }

      return getConfig;
    }()
  }]);

  return ConfirmationValidator;
}(Validator);
/** Used for creating accounts to be sent with requests. */


var Account = /*#__PURE__*/function () {
  /**
   * @param signingKey the account signing key
   * @param accountNumber the account number
   */
  function Account(signingKey, accountNumber) {
    _classCallCheck(this, Account);

    var accountKeys;

    if (accountNumber && signingKey) {
      accountKeys = Account.fromBothKeys(signingKey, accountNumber);
    } else if (signingKey) {
      accountKeys = Account.fromSigningKey(signingKey);
    } else {
      accountKeys = Account.random();
    }

    this.accountNumber = accountKeys[0];
    this.signingKey = accountKeys[1];
  }

  _createClass(Account, [{
    key: "accountNumberHex",
    get:
    /** The 32 byte account number as a 32 byte hex string. */
    function get() {
      return uint8arrayToHex(this.accountNumber);
    }
    /** The 64 byte account signing key as a 32 byte hex string. */

  }, {
    key: "signingKeyHex",
    get: function get() {
      return uint8arrayToHex(this.signingKey).slice(0, 64);
    }
    /**
     * Creates a signature for the given message.
     * @param message the message to generate the signature for
     * @returns the generated signature
     */

  }, {
    key: "createSignature",
    value: function createSignature(message) {
      var encodedData = new TextEncoder().encode(message);
      var signatureArray = tweetnacl.sign(encodedData, this.signingKey);
      var signature = uint8arrayToHex(signatureArray);
      return signature.substring(0, 128);
    }
    /**
     * Creates a signed data message with the given data.
     * @param data the data to be passed along in the message
     * @returns the signed message
     */

  }, {
    key: "createSignedMessage",
    value: function createSignedMessage(data) {
      return {
        message: data,
        node_identifier: this.accountNumberHex,
        signature: this.createSignature(JSON.stringify(data))
      };
    }
    /**
     * Creates a block data object without a signature.
     * @param balanceLock the latest user balance lock
     * @param transactions the transactions inside of the block
     */

  }, {
    key: "createBlockData",
    value: function createBlockData(balanceLock, transactions) {
      var message = {
        balance_key: balanceLock,
        txs: transactions.sort(function (tx1, tx2) {
          return tx1.recipient.localeCompare(tx2.recipient);
        })
      };
      return {
        account_number: this.accountNumberHex,
        message: message
      };
    }
    /**
     * Creates a signed block object.
     * @param balanceLock the latest user balance lock
     * @param transactions the transactions inside of the block
     */

  }, {
    key: "createBlockMessage",
    value: function createBlockMessage(balanceLock, transactions) {
      var blockData = this.createBlockData(balanceLock, transactions);
      return _objectSpread(_objectSpread({}, blockData), {}, {
        signature: this.createSignature(JSON.stringify(blockData.message))
      });
    }
  }], [{
    key: "fromSigningKey",
    value: function fromSigningKey(signingKey) {
      var _tweetnacl$sign$keyPa = tweetnacl.sign.keyPair.fromSeed(hexToUint8Array(signingKey)),
          accountNumber = _tweetnacl$sign$keyPa.publicKey,
          signingKey_ = _tweetnacl$sign$keyPa.secretKey;

      return [accountNumber, signingKey_];
    }
  }, {
    key: "fromBothKeys",
    value: function fromBothKeys(signingKey, accountNumber) {
      var accountNumberArray = hexToUint8Array(accountNumber);
      var signingKeyArray = new Uint8Array(64);
      signingKeyArray.set(hexToUint8Array(signingKey));
      signingKeyArray.set(accountNumberArray, 32);
      return [accountNumberArray, signingKeyArray];
    }
  }, {
    key: "random",
    value: function random() {
      var _createAccountData = createAccountData(),
          accountNumber = _createAccountData.publicKey,
          signingKey = _createAccountData.signingKey;

      return [accountNumber, signingKey];
    }
    /**
     * Checks if the signing key pair is valid.
     * @param signingKey the given signing key hex string
     * @param accountNumber the given account number hex string
     */

  }, {
    key: "isValidPair",
    value: function isValidPair(signingKey, accountNumber) {
      try {
        return new Account(signingKey).accountNumberHex === accountNumber;
      } catch (_) {
        return false;
      }
    }
  }]);

  return Account;
}();

var PaymentHandler = /*#__PURE__*/function () {
  function PaymentHandler(_ref) {
    var bankUrl = _ref.bankUrl;

    _classCallCheck(this, PaymentHandler);

    this.bank = new Bank(bankUrl);
  }
  /** This must be ran before using the client. */


  _createClass(PaymentHandler, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee55() {
        return regeneratorRuntime.wrap(function _callee55$(_context55) {
          while (1) {
            switch (_context55.prev = _context55.next) {
              case 0:
                _context55.next = 2;
                return this.updateBank();

              case 2:
                _context55.next = 4;
                return this.updatePrimaryValidator();

              case 4:
              case "end":
                return _context55.stop();
            }
          }
        }, _callee55, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "updateBank",
    value: function () {
      var _updateBank = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee56() {
        var config;
        return regeneratorRuntime.wrap(function _callee56$(_context56) {
          while (1) {
            switch (_context56.prev = _context56.next) {
              case 0:
                _context56.next = 2;
                return this.bank.getConfig().catch(function (err) {
                  return throwError("Failed to load the bank's config.", err);
                });

              case 2:
                config = _context56.sent;
                this.bankConfig = config; // it has to be correct if it got this far without the error

              case 4:
              case "end":
                return _context56.stop();
            }
          }
        }, _callee56, this);
      }));

      function updateBank() {
        return _updateBank.apply(this, arguments);
      }

      return updateBank;
    }()
  }, {
    key: "updatePrimaryValidator",
    value: function () {
      var _updatePrimaryValidator = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee57() {
        var config;
        return regeneratorRuntime.wrap(function _callee57$(_context57) {
          while (1) {
            switch (_context57.prev = _context57.next) {
              case 0:
                if (this.bankConfig) {
                  _context57.next = 2;
                  break;
                }

                return _context57.abrupt("return");

              case 2:
                _context57.next = 4;
                return this.bank.getBankPV();

              case 4:
                this.primaryValidator = _context57.sent;
                _context57.next = 7;
                return this.primaryValidator.getConfig().catch(function (err) {
                  return throwError("Failed to load the primary validator's config.", err);
                });

              case 7:
                config = _context57.sent;
                this.primaryValidatorConfig = config;

              case 9:
              case "end":
                return _context57.stop();
            }
          }
        }, _callee57, this);
      }));

      function updatePrimaryValidator() {
        return _updatePrimaryValidator.apply(this, arguments);
      }

      return updatePrimaryValidator;
    }()
    /**
     * Creates a transaction with a specific amount of coins to a given account from the sender.
     * @param sender Theobject with the sender's account details
     * @param txs An array with multiple transactions with details of the amount and recipient
     *
     */

  }, {
    key: "createTransaction",
    value: function () {
      var _createTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee58(sender, txs) {
        var _yield$this$primaryVa, balanceLock, transactions;

        return regeneratorRuntime.wrap(function _callee58$(_context58) {
          while (1) {
            switch (_context58.prev = _context58.next) {
              case 0:
                txs = txs.map(function (tx) {
                  if (tx.memo) {
                    tx.memo = tx.memo.trim();
                    if (!/^[a-zA-Z0-9_ ]*$/.test(tx.memo)) throwError("Invalid memo", "Memo can only contain alphanumeric characters, spaces, and underscores");
                    if (tx.memo.length > 64) throwError("Invalid memo", "Memo cannot exceed 64 characters");
                  }

                  if (tx.memo === "") delete tx.memo;
                  return tx;
                });
                _context58.next = 3;
                return this.primaryValidator.getAccountBalanceLock(sender.accountNumberHex).catch(function (err) {
                  return throwError("Failed to load the balance lock from the primary validator to send the transaction.", err);
                });

              case 3:
                _yield$this$primaryVa = _context58.sent;
                balanceLock = _yield$this$primaryVa.balance_lock;
                transactions = [].concat(_toConsumableArray(txs), _toConsumableArray([this.bankConfig, this.primaryValidatorConfig].map(function (config) {
                  return {
                    amount: config.default_transaction_fee,
                    fee: config.node_type,
                    recipient: config.account_number
                  };
                })));
                return _context58.abrupt("return", {
                  balanceLock: balanceLock,
                  transactions: transactions,
                  sender: sender
                });

              case 7:
              case "end":
                return _context58.stop();
            }
          }
        }, _callee58, this);
      }));

      function createTransaction(_x60, _x61) {
        return _createTransaction.apply(this, arguments);
      }

      return createTransaction;
    }()
    /**
     * Sends a specific amount of coins to a given account from the sender.
     * @param transaction the object containing transaction details
     */

  }, {
    key: "broadcastTransaction",
    value: function () {
      var _broadcastTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee59(transaction) {
        return regeneratorRuntime.wrap(function _callee59$(_context59) {
          while (1) {
            switch (_context59.prev = _context59.next) {
              case 0:
                _context59.next = 2;
                return this.bank.addBlocks(transaction.balanceLock, transaction.transactions, transaction.sender);

              case 2:
              case "end":
                return _context59.stop();
            }
          }
        }, _callee59, this);
      }));

      function broadcastTransaction(_x62) {
        return _broadcastTransaction.apply(this, arguments);
      }

      return broadcastTransaction;
    }()
    /**
     * Sends a specific amount of coins to a given account from the sender.
     * @param transferDetails The object with transfer details like sender, recipient and amount
     */

  }, {
    key: "sendCoins",
    value: function () {
      var _sendCoins = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee60(_ref2) {
        var sender, recipient, amount, _ref2$memo, memo, recipientAccount, transaction;

        return regeneratorRuntime.wrap(function _callee60$(_context60) {
          while (1) {
            switch (_context60.prev = _context60.next) {
              case 0:
                sender = _ref2.sender, recipient = _ref2.recipient, amount = _ref2.amount, _ref2$memo = _ref2.memo, memo = _ref2$memo === void 0 ? "" : _ref2$memo;
                recipientAccount = typeof recipient === "string" ? recipient : recipient.accountNumberHex;
                _context60.next = 4;
                return this.createTransaction(sender, [{
                  amount: amount,
                  memo: memo,
                  recipient: recipientAccount
                }]);

              case 4:
                transaction = _context60.sent;
                _context60.next = 7;
                return this.broadcastTransaction(transaction);

              case 7:
              case "end":
                return _context60.stop();
            }
          }
        }, _callee60, this);
      }));

      function sendCoins(_x63) {
        return _sendCoins.apply(this, arguments);
      }

      return sendCoins;
    }()
    /**
     * Sends multiple amounts of coins to multiple recipients.
     * @param sender Theobject with the sender's account details
     * @param txs An array with multiple transactions with details of the amount and recipient
     */

  }, {
    key: "sendBulkTransactions",
    value: function () {
      var _sendBulkTransactions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee61(sender, txs) {
        var transaction;
        return regeneratorRuntime.wrap(function _callee61$(_context61) {
          while (1) {
            switch (_context61.prev = _context61.next) {
              case 0:
                _context61.next = 2;
                return this.createTransaction(sender, txs);

              case 2:
                transaction = _context61.sent;
                _context61.next = 5;
                return this.broadcastTransaction(transaction);

              case 5:
              case "end":
                return _context61.stop();
            }
          }
        }, _callee61, this);
      }));

      function sendBulkTransactions(_x64, _x65) {
        return _sendBulkTransactions.apply(this, arguments);
      }

      return sendBulkTransactions;
    }()
  }]);

  return PaymentHandler;
}();

var AccountPaymentHandler = /*#__PURE__*/function () {
  function AccountPaymentHandler(_ref3) {
    var account = _ref3.account,
        bankUrl = _ref3.bankUrl;

    _classCallCheck(this, AccountPaymentHandler);

    this.account = account;
    this.client = new PaymentHandler({
      bankUrl: bankUrl
    });
  }

  _createClass(AccountPaymentHandler, [{
    key: "init",
    value: function () {
      var _init2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee62() {
        return regeneratorRuntime.wrap(function _callee62$(_context62) {
          while (1) {
            switch (_context62.prev = _context62.next) {
              case 0:
                _context62.next = 2;
                return this.client.init();

              case 2:
              case "end":
                return _context62.stop();
            }
          }
        }, _callee62, this);
      }));

      function init() {
        return _init2.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "sendCoins",
    value: function () {
      var _sendCoins2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee63(recipient, amount) {
        var memo,
            _args63 = arguments;
        return regeneratorRuntime.wrap(function _callee63$(_context63) {
          while (1) {
            switch (_context63.prev = _context63.next) {
              case 0:
                memo = _args63.length > 2 && _args63[2] !== undefined ? _args63[2] : "";
                _context63.next = 3;
                return this.client.sendCoins(new TransferDetails(this.account, recipient, amount, memo));

              case 3:
              case "end":
                return _context63.stop();
            }
          }
        }, _callee63, this);
      }));

      function sendCoins(_x66, _x67) {
        return _sendCoins2.apply(this, arguments);
      }

      return sendCoins;
    }()
  }, {
    key: "sendBulkTransactions",
    value: function () {
      var _sendBulkTransactions2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee64(transactions) {
        return regeneratorRuntime.wrap(function _callee64$(_context64) {
          while (1) {
            switch (_context64.prev = _context64.next) {
              case 0:
                _context64.next = 2;
                return this.client.sendBulkTransactions(this.account, transactions);

              case 2:
              case "end":
                return _context64.stop();
            }
          }
        }, _callee64, this);
      }));

      function sendBulkTransactions(_x68) {
        return _sendBulkTransactions2.apply(this, arguments);
      }

      return sendBulkTransactions;
    }()
  }]);

  return AccountPaymentHandler;
}();

exports.Account = Account;
exports.AccountPaymentHandler = AccountPaymentHandler;
exports.Bank = Bank;
exports.ConfirmationValidator = ConfirmationValidator;
exports.PaymentHandler = PaymentHandler;
exports.PrimaryValidator = PrimaryValidator;
exports.ServerNode = ServerNode;
exports.Validator = Validator;
